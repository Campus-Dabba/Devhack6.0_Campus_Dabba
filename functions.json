[
  {
    "routine_name": "set_user_role",
    "routine_definition": "\nBEGIN\n  -- Verify the role is valid\n  IF new_role NOT IN ('cook', 'student', 'admin') THEN\n    RAISE EXCEPTION 'Invalid role: %', new_role;\n  END IF;\n\n  -- Update the user's role in auth.users\n  UPDATE auth.users\n  SET raw_user_meta_data = \n    CASE \n      WHEN raw_user_meta_data IS NULL THEN \n        jsonb_build_object('role', new_role)\n      ELSE \n        raw_user_meta_data || jsonb_build_object('role', new_role)\n    END\n  WHERE id = user_id;\nEND;\n"
  },
  {
    "routine_name": "is_admin",
    "routine_definition": "\nBEGIN\n    RETURN EXISTS (\n        SELECT 1 FROM admins\n        WHERE admins.id = input_user_id\n    );\nEND;\n"
  },
  {
    "routine_name": "create_admin",
    "routine_definition": "\nDECLARE\n    key_valid BOOLEAN;\nBEGIN\n    SELECT verify_admin_key(admin_key) INTO key_valid;\n    \n    IF NOT key_valid THEN\n        RETURN FALSE;\n    END IF;\n    \n    INSERT INTO admins (id)\n    VALUES (user_id);\n    \n    UPDATE admin_keys\n    SET used = TRUE,\n        used_by = user_id\n    WHERE key = admin_key;\n    \n    RETURN TRUE;\nEND;\n"
  },
  {
    "routine_name": "generate_admin_key",
    "routine_definition": "\nDECLARE\n    new_key TEXT;\nBEGIN\n    new_key := encode(gen_random_bytes(16), 'hex');\n    \n    INSERT INTO admin_keys (key, expires_at)\n    VALUES (new_key, NOW() + INTERVAL '30 days');\n    \n    RETURN new_key;\nEND;\n"
  },
  {
    "routine_name": "verify_admin_key",
    "routine_definition": "\nBEGIN\n    RETURN EXISTS (\n        SELECT 1 FROM admin_keys \n        WHERE key = key_to_verify\n        AND NOT used\n        AND expires_at > NOW()\n    );\nEND;\n"
  },
  {
    "routine_name": "update_updated_at_column",
    "routine_definition": "\nBEGIN\n    NEW.updated_at = timezone('utc'::text, now());\n    RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_order_items_updated_at",
    "routine_definition": "\nBEGIN\n    NEW.updated_at = timezone('utc'::text, now());\n    RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_cook_order_stats",
    "routine_definition": "\nBEGIN\n  INSERT INTO cook_orders (cook_id, total_orders, pending_orders)\n  VALUES (NEW.cook_id, 1, 1)\n  ON CONFLICT (cook_id)\n  DO UPDATE SET\n    total_orders = cook_orders.total_orders + 1,\n    pending_orders = cook_orders.pending_orders + 1;\n  RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_cook_earnings",
    "routine_definition": "\nBEGIN\n  IF NEW.status = 'completed' AND OLD.status = 'pending' THEN\n    UPDATE cook_orders\n    SET earnings = earnings + NEW.amount\n    WHERE cook_id = NEW.cook_id;\n  END IF;\n  RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_cook_rating",
    "routine_definition": "\nDECLARE\n  avg_rating NUMERIC;\nBEGIN\n  SELECT AVG(rating) INTO avg_rating\n  FROM cook_ratings\n  WHERE cook_id = NEW.cook_id;\n  \n  UPDATE cooks\n  SET rating = avg_rating\n  WHERE id = NEW.cook_id;\n  \n  RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_order_status_stats",
    "routine_definition": "\nBEGIN\n  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN\n    UPDATE cook_orders\n    SET \n      completed_orders = completed_orders + 1,\n      pending_orders = pending_orders - 1\n    WHERE cook_id = NEW.cook_id;\n  END IF;\n  RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_orders_updated_at",
    "routine_definition": "\nBEGIN\n    NEW.updated_at = timezone('utc'::text, now());\n    RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "sync_user_on_signup",
    "routine_definition": "\nBEGIN\n    -- Insert into users table with simplified column structure\n    -- Using only basic columns that should exist in most users tables\n    INSERT INTO users (\n        id, \n        email, \n        first_name, \n        last_name, \n        phone, \n        created_at\n    )\n    VALUES (\n        NEW.id, \n        NEW.email, \n        COALESCE(NEW.raw_user_meta_data->>'first_name', ''),\n        COALESCE(NEW.raw_user_meta_data->>'last_name', ''),\n        COALESCE(NEW.raw_user_meta_data->>'phone', ''),\n        NOW()\n    )\n    ON CONFLICT (id) DO UPDATE SET\n        email = EXCLUDED.email,\n        first_name = COALESCE(EXCLUDED.first_name, users.first_name),\n        last_name = COALESCE(EXCLUDED.last_name, users.last_name),\n        phone = COALESCE(EXCLUDED.phone, users.phone);\n    RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "is_admin",
    "routine_definition": "\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM admins WHERE user_id = auth.uid()\n  );\nEND;\n"
  },
  {
    "routine_name": "handle_new_user",
    "routine_definition": "\nBEGIN\n  -- Simple insert without complex logic\n  INSERT INTO public.users (id, email, created_at, updated_at, role)\n  VALUES (\n    new.id, \n    new.email, \n    COALESCE(new.created_at, now()), \n    now(),\n    COALESCE(new.raw_user_meta_data->>'role', 'student')\n  )\n  ON CONFLICT (id) DO NOTHING;\n  \n  RETURN new;\nEXCEPTION WHEN OTHERS THEN\n  -- Don't fail auth creation if user record creation fails\n  RETURN new;\nEND;\n"
  },
  {
    "routine_name": "list_available_admin_keys",
    "routine_definition": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        ak.key,\n        ak.created_at,\n        ak.expires_at\n    FROM admin_keys ak\n    WHERE ak.used = FALSE\n    AND ak.expires_at > NOW();\nEND;\n"
  },
  {
    "routine_name": "create_admin",
    "routine_definition": "\nDECLARE\n    key_valid BOOLEAN;\nBEGIN\n    -- Verify the admin key\n    SELECT verify_admin_key(admin_key) INTO key_valid;\n    \n    IF NOT key_valid THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Insert into admins table (only id and email since those are the columns we have)\n    INSERT INTO admins (id, email)\n    VALUES (user_id, admin_email);\n    \n    -- Mark the admin key as used\n    UPDATE admin_keys\n    SET used = TRUE,\n        used_by = user_id\n    WHERE key = admin_key;\n    \n    RETURN TRUE;\nEND;\n"
  },
  {
    "routine_name": "update_cook_orders_count",
    "routine_definition": "\nBEGIN\n    INSERT INTO cook_orders (cook_id, total_orders, pending_orders, earnings)\n    VALUES (NEW.cook_id, 1, 1, NEW.total)\n    ON CONFLICT (cook_id) DO UPDATE\n    SET total_orders = cook_orders.total_orders + 1,\n        pending_orders = cook_orders.pending_orders + 1,\n        earnings = cook_orders.earnings + NEW.total;\n    RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_cook_order_status_count",
    "routine_definition": "\nBEGIN\n    IF NEW.status = 'completed' AND OLD.status = 'pending' THEN\n        UPDATE cook_orders\n        SET pending_orders = pending_orders - 1,\n            completed_orders = completed_orders + 1\n        WHERE cook_id = NEW.cook_id;\n    END IF;\n    RETURN NEW;\nEND;\n"
  }
]